Redis提供了两种不同的持久化方法来将数据存储到硬盘里面．
- 一种方法叫快照(snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面．　
- 另一种方法叫追加文件(append-only file，AOF)，它会在执行写命令时，将被执行的写命令复制到硬盘里面

这两种持久化方法既可以同时使用，又可以单独使用，在某些情况下甚至可以两种方法都不使用，具体选择哪种持久化方法需要根据用户的数据以及应用来决定．

### 1. 快照持久化

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本．在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器时使用．

#### 1.1 快照持久化选项
```
save 60 1000
stop-writes-on-bgsave-error no
rdbcompression yes
dbfinename dump.rdb
dir ./
```
上面配置说明了多久执行一次自动快照的操作，在创建快照失败后是否仍然继续执行写命令，是否对快照文件进行压缩，如何命名硬盘上的快照文件以及决定快照文件的存储位置

根据配置，快照将被写入dbfilename选项指定的文件里面，并存储在dir选项指定的路径上面．如果在新的快照文件创建完毕之前，Redis，系统或者硬件这三者之中任意一个崩溃，那么Redis将丢失最近一次创建快照之后写入的所有数据.

#### 1.2 创建快照

创建快照的办法有以下几种：

(1) 客户端可以通过向Redis发送`BGSAVE`命令来创建一个快照．对于支持`BGSAVE`命令的平台来说，Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求.

(2) 客户端还可以通过向Redis发送`SAVE`命令来创建一个快照．接到`SAVE`命令的Redis服务器在快照创建完毕之前不再响应任何其他命令．`SAVE`命令并不常用，我们通常只会在没有足够内存去执行`BGSAVE`命令的情况下，又或者即使等待持久化操作完毕也无所谓的情况下，才会使用这个命令．

(3) 如果用户设置了`save`配置选项，比如上面的`save 60 1000`，那么从Redis最近一次创建快照之后算起，当"60秒之内有1000次写入"这个条件被满足时，Redis就会自动触发`BGSAVE`命令．如果用户设置了多个`save`配置选项，那么当任意一个save配置选项所设置的条件被满足时，Redis就会触发一次`BGSAVE`命令．

(3) 当Redis通过`SHUTDOWN`命令接收到关闭服务器的请求时，或者接收到标准`TERM`信号时，会执行一个`SAVE`命令，阻塞所有客户端，不在执行客户端发送的任何命令，并在`SAVE`命令执行完毕之后关闭服务器．

(4) 当一个Redis服务器连接另一个Redis服务器，并向对方发送`SYNC`命令来开始一次复制操作时，如果主服务器目前没有在执行`BGSAVE`操作，或者主服务器并非刚刚执行完`BGSAVE`操作，那么主服务器就会执行`BGSAVE`命令


#### 1.3 缺点

在只使用快照持久化来保存数据时，一定要记住：==如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据==．因此，快照持久化只适用于那些即使丢失一部分数据也不会造成问题的应用程序，而不能接受这种数据损失的应用程序可以考虑适用AOP持久化．

### 2. AOF持久化

AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化．因此，Redis只要从头到尾重新执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集．

#### 2.1 AOF持久化选项

```
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
dir ./
```
上面配置说明了是否适用AOF持久化，多久才将写入的内容同步到硬盘，在对AOF进行压缩的时候能否执行同步操作，以及多久执行一次AOF压缩．

#### 2.2 appendfsync配置选项

下表展示了appendfsync配置选项对AOF文件的同步频率的影响：

选项 | 同步频率
---|---
always | 每个Redis写命令都要同步写入硬盘．这样做会严重降低Redis的速度．
everysec |每秒执行一次同步，显示的将多个写命令同步到硬盘
no | 让操作系统来决定应该何时进行同步

##### 2.2.1 always

如果用户使用`always`选项，那么每个Redis写命令都会被写入硬盘，从而将发生系统崩溃时出现的数据丢失减到最少．但是，因为这种同步策略需要对硬盘进行大量的写入，所以Redis处理命令的速度会受到硬盘性能的限制：转盘式硬盘(spinning disk)每秒下只能处理大约200个写命令，而固态硬盘(solid-state drive SSD)每秒下只能处理几万个写命令．

==警告==

使用固态硬盘的用户谨慎使用`always`选项，因为这个选项让Redis每次只写入一个命令，而不是像其他选项那样一次写入多个命令，这种不断写入少量数据的做法可能会引发严重的写入放大问题，在某些情况下甚至会将固态硬盘的寿命从原来的几年降低为几个月．


##### 2.2.2 everysec

为了兼顾数据安全与写入性能，可以采用`everysec`选项，让Redis以每秒一次的频率对AOF文件进行同步．Redis每秒同步一次AOF文件时的性能和不使用任何持久化特性时的性能相差无几，而通过每秒同步一次AOF文件，即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据．

##### 2.2.3 no

如果用户使用`no`选项，那么Redis将不对AOF文件执行任何显示的同步操作，而是由操作系统来决定应该何时对AOF文件进行同步．这个选项在一般情况下不会对Redis的性能带来影响，但系统崩溃将导致丢失不定数量的数据．另外，如果用户的硬盘处理写入操作的速度不够快的话，那么当缓冲区被等待写入硬盘的数据填满时，Redis写入操作将被阻塞，并导致Redis处理命令请求的速度变慢．因为这个原因，一般来说并不推荐使用`no`选项．


#### 2.3 重写/压缩AOF文件

虽然AOF持久化非常灵活的提供了多种不同的选项来满足不同应用程序对数据安全的不同要求，但AOF持久化也有缺陷，那就是AOF文件的体积大小．

因为随着Redis不断的将被执行的写命令记录到AOF文件中，AOF文件的体积也会不断的增长，在极端情况下，体积不断增大的AOF文件甚至会用完硬盘的所有可用空间．还有另一个问题，因为Redis在重启之后需要通过重新执行AOF文件记录的所有写命令来还原数据集，所以如果AOF文件体积非常大，那么还原操作执行的时间就可能非常长．

为了解决上述AOF体积不断增大的问题，用户可以向Redis发送`BGREWRITEAOF`命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件的体积变的尽可能小．`BGREWRITEAOF`命令与`BGSAVE`创建快照的工作原理类似：同样是创建一个子进程，该子进程来负责对AOF文件进行重写．　因为AOF文件重写也需要用到子进程，所以同样也会遇到与快照持久化因为创建子进程而导致的性能问题和内存占用问题．　更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件的体积大好几倍，在进行AOF重写并删除AOF文件时，删除一个体积达到数十GB大的旧AOF文件可能会导致操作系统挂起数秒．

AOF持久化也可以通过设置如下参数来自动执行`BGREWRITEAOF`：
```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```
如果启用了AOF持久化，那么当AOF文件的体积大于64MB并且AOF文件的体积比上一次重写之后的体积大了至少一倍的时候，Redis将执行重写．





