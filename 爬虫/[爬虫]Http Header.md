
### 1. Http Header
#### 1.1 请求字段

##### 1.1.1 常见请求字段

协议字段名称　| 说明 | 示例
---|---|---
Accept|	能够接受的回应内容类型（Content-Types）。参见内容协商。	|Accept: text/plain
Accept-Charset|	能够接受的字符集|	Accept-Charset: utf-8
Accept-Encoding|	能够接受的编码方式列表。参考HTTP压缩。|	Accept-Encoding: gzip, deflate
Accept-Language|	能够接受的回应内容的自然语言列表。参考 内容协商 。|	Accept-Language: en-US
Connection|该浏览器想要优先使用的连接类型|Connection: keep-alive Connection: Upgrad
Content-Length|	以八位字节数组 （8位的字节）表示的请求体的长度|Content-Length: 348
Content-Type|	请求体的 多媒体类型 （用于POST和PUT请求中）	|Content-Type: application/x-www-form-urlencoded
Date|发送该消息的日期和时间(按照 RFC 7231 中定义的"超文本传输协议日期"格式来发送)|Date: Tue, 15 Nov 1994 08:12:31 GMT	
Host|服务器的域名(用于虚拟主机 )，以及服务器所监听的 传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。|Host: en.wikipedia.org:80 Host: en.wikipedia.org
User-Agent|浏览器的浏览器身份标识字符串|User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0

==备注==

HTTP是一个请求<->响应模式的典型范例,即客户端向服务器发送一个请求信息,服务器来响应这个信息。在老的HTTP版本中,每个请求都将被创建一个新的客户端->服务器的连接,在这个连接上发送请求,然后接收请求。这样的模式有一个很大的优点就是,它很简单,很容易理解和编程实现;它也有一个很大的缺点就是,它效率很低,因此Keep-Alive被提出用来解决效率低的问题。

##### 1.1.2 Example

我们以百度请求为例：
```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate, sdch, br
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Cookie:xxx
Host:www.baidu.com
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36
```
#### 1.2. 回应字段

##### 1.2.1 常见回应字段

协议字段名称　| 说明 | 示例
---|---|---
Cache-Control|向从服务器直到客户端在内的所有缓存机制告知，它们是否可以缓存这个对象。其单位为秒	|Cache-Control: max-age=3600
Content-Encoding|在数据上使用的编码类型。参考 超文本传输协议压缩 。|Content-Encoding: gzip
Content-Language|内容所使用的语言|Content-Language: da
Content-Length|回应消息体的长度，以 字节 （8位为一字节）为单位|Content-Length: 348
Date|此条消息被发送时的日期和时间|Date: Tue, 15 Nov 1994 08:12:31 GMT
ETag|对于某个资源的某个特定版本的一个标识符，通常是一个消息散列	|ETag: "737060cd8c284d8af7ad3082f209582d"
Expires|指定一个日期/时间，超过该时间则认为此回应已经过期|Expires: Thu, 01 Dec 1994 16:00:00 GMT
Location|用来进行重定向 ，或者在创建了某个新资源时使用。|Location: http://www.w3.org/pub/WWW/People.html
Set-Cookie|HTTP cookie|	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
Status|通用网关接口协议头字段，用来说明当前这个超文本传输协议回应的状态 。普通的超文本传输协议回应，会使用单独的“状态行”（"Status-Line"）作为替代，这一点是在 RFC 7230 中定义的。|Status: 200 OK

##### 1.2.2 Example

我们以百度请求返回为例：
```
Cache-Control:private
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html;charset=utf-8
Date:Sat, 10 Jun 2017 04:05:36 GMT
Expires:Sat, 10 Jun 2017 04:05:36 GMT
Server:bfe/1.0.8.18
Set-Cookie:BDSVRTM=144; path=/
Set-Cookie:H_PS_PSSID=1432_21111_17001_22525_22919_20930; path=/; domain=.baidu.com
Set-Cookie:__bsi=11574364076479570044_00_0_I_R_146_0303_C02F_N_I_I_0; expires=Sat, 10-Jun-17 04:05:41 GMT; domain=www.baidu.com; path=/
Set-Cookie:BD_HOME=1; path=/
Strict-Transport-Security:max-age=172800
Transfer-Encoding:chunked
X-UA-Compatible:IE=Edge,chrome=1
```

### 2. Http 状态码

HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。所有状态码的第一个数字代表了响应的五种状态之一。

状态码 | 说明
---|---
1xx|消息
2xx|成功
3xx|重定向
4xx|客户端错误
5xx|服务器错误	

#### 2.1 1xx

这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。

#### 2.2 2xx

这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。

##### 2.2.1 200 OK

请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。

##### 2.2.2 201 Created

请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted'。

##### 2.2.3 202 Accepted

服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。

##### 2.2.4 203 Non-Authoritative Information（自HTTP / 1.1起）

服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。

##### 2.2.5 204 No Content

服务器成功处理了请求，没有返回任何内容。

#### 2.3 3xx

这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。

当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向.

##### 2.3.1 300 Multiple Choices

被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。

除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。

如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。

##### 2.3.2 301 Moved Permanently

被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。

如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。

##### 2.3.3 302 Found

要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。[20]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。

如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。

#### 2.4 4xx

这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。

如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。

##### 2.4.1 400 Bad Request

由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。

##### 2.4.2 401 Unauthorized（RFC 7235）

类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。[33]如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。

注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。

##### 2.4.3 403 Forbidden

服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。

##### 2.4.4 404 Not Found

请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

#### 2.5 5xx

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。

##### 2.5.1 500 Internal Server Error
通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。

##### 2.5.2 503 Service Unavailable
由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。

参考：https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8

https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81
