---
layout: post
author: sjf0115
title: Flink 内部原理之内存管理技巧
date: 2018-02-02 11:40:01
tags:
  - Flink
  - Flink内部原理

categories: Flink
permalink: flink-batch-internals-memory-management-juggling
---

现在，许多用于分析大型数据集的开源系统都是用 `Java` 或其他基于 `JVM` 的编程语言来实现的。最着名的例子是 `Apache Hadoop`，而且还有更新的框架，例如 `Apache Spark`，`Apache Drill`，同时 `Apache Flink` 也在 `JVM` 上运行。基于 `JVM` 的数据分析引擎面临的一个共同挑战是将大量数据存储在内存中 - 无论是缓存还是高效处理（如排序和连接）。一个难以配置且可靠性和性能具有不可预测性的系统与一个运行稳定且配置较少的系统之间的区别在于是否能很好的管理好 `JVM` 内存。

在这篇博客文章中，我们将讨论 `Apache Flink` 如何管理内存，讨论它的自定义反序列化/序列化栈以及如何操作二进制数据。

### 1. 数据对象？ 让我们把它们放在堆上！

在 `JVM` 中处理大量数据最直接的方法就是将其作为堆中的对象并对这些对象进行操作。将数据集以对象进行缓存就像维护包含每个记录对象的列表一样简单。内存排序可以简单地对对象列表进行排序。但是，这种方法有一些显着的缺点:

(1) 首先，当大量对象不断创建并且经常失效时，监控和控制堆内存的使用情况并不是一件容易的事情。内存过度配置会立即杀死 `JVM` 并 抛出 `OutOfMemoryError` 错误。

(2) 另一个方面是对有数GB且有大量新对象的 `JVMs` 进行垃圾收集。在这种情况下垃圾收集的开销可以轻松达到50％以上。

(3) 最后，`Java` 对象带来一定的空间开销，这取决于 `JVM` 和平台。对于具有许多小对象的数据集，这会显着降低有效可用的内存量。鉴于精明的系统设计和用例特定的系统参数调整，堆内存的使用可以或多或少地受到控制，并避免 `OutOfMemoryErrors`。但是，这样的设置相当脆弱，尤其是在数据特征或执行环境改变的情况下。































原文:https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html
