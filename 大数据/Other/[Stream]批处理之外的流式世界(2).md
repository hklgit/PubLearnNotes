---
layout: post
author: sjf0115
title: Stream 批处理之外的流式世界(2)
date: 2018-01-09 17:54:01
tags:
  - Stream

categories: Stream
---

### 1. 总结和路线图

在[Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101)中，我们首先澄清了一些术语。然后我开始区分有限数据和无限数据。有限数据源的大小是有限的，通常被称为`batch`数据。无限数据源可能具有无限大小，并且通常被称为`streaming`数据。我尽量避免使用`batch`和`streaming`术语来指代数据源，因为这些名称带有一些误导并经常受到限制。

然后，我继续定义了批处理引擎和流引擎之间的区别：批处理引擎是那些仅为有限数据而设计的引擎，而流引擎是设计时考虑到了无限数据。我的目标是在引用执行引擎时只使用`batch`和`streaming`术语。

在术语之后，我介绍了与处理无限数据有关的两个重要概念。我首先确定了`事件时间`(事件发生的时间)和`处理时间`(处理期间观察到时间)之间的关键区别。这为[Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101)提出的主要论点之一提供了基础：如果你关心事件实际发生的正确性和上下文，则必须分析与固有事件时间相关的数据，而不是分析它们的在处理过程中遇到处理时间。

然后，我介绍了窗口的概念(即，将数据集按时间界线划分)，这是一种常见的方法，用于处理无限数据源在技术上永远不会结束的事实。窗口化策略中比较简单的是固定窗口的和滑动窗口，也还有更复杂的窗口类型，例如会话窗口(其中窗口由数据本身的特征定义，例如捕获每个用户的活动会话，紧跟不活跃的间隙)应用也比较广泛。

除了这两个概念之外，我们现在要仔细研究一下三个概念：
- `Watermarks`是关于事件时间输入完整性的概念。具有时间X值的`watermark`表示：`已经观察到所有输入数据并且事件时间小于X`。因此，当不知道无限数据源什么时候结束时，`watermark`就用作进度的度量。
- `Triggers`是一种机制，用于声明窗口输出何时应相对于某个外部信号实现。触发器在选择何时发送输出方面提供了灵活性。它们还可以随着时间的变化多次观察窗口的输出(observe the output for a window multiple times as it evolves)。这为随着时间的推移而修改结果提供了可能，这又开启了随时间改进结果的大门，这允许在数据到达时提供推测结果，并且随时间处理上游数据的变化或相对于`watermark`迟到的数据(例如，移动场景 ，其中某个人的电话在该人离线时记录各种动作和他们的事件时间，然后在重新获得连接时继续上传这些事件进行处理。)
- `Accumulation`

最后，因为我认为理解这些概念之间的关系比较容易，我们将重新回顾以前的问题，并在回答下面四个问题中探索新的问题，所有这些问题对于每一个无限数据处理问题都是至关重要的：

(1) `What`计算出什么样的结果？这个问题由流水线内的`转换类型`来回答。这包括诸如计算总和，构造直方图，训练机器学习模型等。这也是经典批处理回答的问题。

(2) `Where`事件发生的时间是在哪里计算的？ 这个问题将由管道内的`基于事件时间的窗口`来回答。这包括[Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101)介绍的窗口常见示例(固定，滑动和会话窗口)，不使用窗口概念的用例(例如，[Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101)中描述的与时间无关的处理；经典的批处理也通常属于这种类别)以及其他更复杂的窗口类型，例如有时间限制的拍卖。还要注意，也可以包含处理时间窗口，如果当记录到达系统时将摄入时间作为事件时间时。

(3) `When`处理时间什么时候被物化的？这个问题通过使用`watermark`和`触发器`来回答。在这个主题上有无限的变化，但是最常见的模式是使用`watermark`来描述给定窗口的输入是否完成，使用触发器允许指定早期结果(在窗口完成之前发送推测的部分结果)和后期结果(`watermark`仅仅是对完整性的估计，在`watermark`声明给定窗口的输入完成之后可能到达更多的输入数据的情况)。

(4) `How`如何使结果更加精致？这个问题由所使用的累积(`accumulation`)类型来回答：丢弃(结果都是独立的和不同的)，累积(后来的结果建立在先前的结果之上)，或者累积和撤回(累积值加上撤回先前发送的已被触发值)(the accumulating value plus a retraction for the previously triggered value(s) are emitted)。

在这篇文章的其余内容，我们将更详细地讨论这些问题。

### 2. Streaming 101 总结

首先，让我们回顾一下在[Streaming 101](https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101)中提出的一些概念，但是这次还有一些详细的例子，这些例子将有助于我们更好的理解这些概念。

#### 2.1 What: transformations

在经典的批处理应用中的转换操作回答了这个问题：`计算出什么样的结果？`，即使你们中的很多人可能对经典的批处理已经很熟悉了，我们还是从那里开始，因为它是我们添加所有其他的概念的基础。

在本节中，我们将看到一个简单的例子：在由10个值组成的简单数据集上计算键控整数和。如果你想要一个更实际一点的话，你可以把它想象成一个个人团队通过把自己的独立分数结合在一起来玩某种手机游戏的整体得分。 您可以想象它对于计费和使用情况监控用例同样适用。

对于每个示例，我将包含一个`Dataflow Java SDK`伪代码的简短片段，以更好的了解管道的定义。从某种意义上说，这是伪代码，有时我会弯曲规则以使示例更清晰，更详细(比如使用具体的I/O源)，或者简化名称(`Java`中当前的触发器名称非常冗长；为了清晰，我将使用更简单的名称)。除了那些小的东西（其中大部分我在Postscript中明确列举）之外，它基本上是真实的Dataflow SDK代码。 对于那些对可以编译和运行自己的类似示例感兴趣的人，我还会提供一个实际代码演练的链接。









































原文:https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-102
