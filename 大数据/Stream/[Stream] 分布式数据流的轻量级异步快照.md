---
layout: post
author: sjf0115
title: Stream 分布式数据流的轻量级异步快照.md
date: 2018-03-02 18:04:01
tags:
  - Stream

categories: Stream
permalink: lightweight-asynchronous-snapshots-for-distributed-dataflows
---

### 1. 概述

目前已知的确保有状态处理系统上的 `exactly-once` 语义的方法依赖于执行状态的全局一致快照。但是，存在两个主要缺点，使得它们在实时流处理时效率低下。同步快照技术会停止分布式计算的执行，以便获得整体状态的一致视图。此外，持久化存储所有传输中的记录以及算子状态，这会导致比所需的快照要更大。

因此，提出了一种新的分布式快照的算法，这是一种适用于现代数据流执行引擎的轻量级算法，可最大限度地减少空间需求，让快照发生时对系统的影响降到最低。这种算法不会停止流处理，它只会引入很少的运行时间开销，而且对于整个无环图的拓扑结构，只对有状态的算子进行快照，因此快照的大小也会占用很小的空间。该算法不会对执行产生重大影响，保证线性可伸缩性，并且可以在频繁的快照下正常运行。

这里所说的新型的快照算法，既适用于有向无环图，也适用于有向有环图。本文重点关注在有向无环图中的应用，即在 `Apache Flink` 中的异步屏障快照（Asynchronous Barrier Snapshotting (ABS)）。

### 2. Apache Flink System

`Apache Flink` 围绕通用运行时引擎进行架构，可以统一处理批处理和流式作业。Flink 中的作业被编译成任务的有向图。数据元素从外部数据源获取，并以流水线方式通过任务图。任务持续不断的操作基于接收到的输入的内部状态，并产生新的输出。

#### 2.1 流处理编程模型

可以从外部来源（例如消息队列，套接字流，自定义生成器）或通过调用其他 `DataStream` 上的操作来创建 `DataStreams`。`DataStreams` 支持多种算子，如 `map`，`filter` 和 `reduce` 等形式的高阶函数，这些函数在每个记录上逐步应用并生成新的 `DataStream`。每个算子可以通过将并行实例放置在相应流的不同分区上运行来并行化，从而允许分布式执行流转换。

下面的代码示例中显示了如何在 `Apache Flink` 中实现简单的 `Word Count` 程序。在此程序中，从文本文件中读取单词，并将每个单词的当前计数打印到标准输出上。这是一个有状态的流处理程序，所以数据源需要知道它们在文件中的当前偏移量，并且需要计数器来将每个单词的当前计数保持在内部状态中。

![]()

#### 2.2 分布式数据流执行

当用户执行一个应用程序时，所有的 `DataStream` 算子都将编译成一个执行图，原理上为一个有向图 `G =（T，E）`，其中顶点 `T` 表示任务，边 `E` 表示两个任务之间的数据通道。上图就描绘了一个 `Word Count` 例子的执行图。如图所示，算子的每个实例都封装在相应的任务上。任务可以进一步细分为没有输入通道的数据源（`Source`）以及没有输出通道的 `Sink`。此外，`M` 表示任务在并行执行期间传输的所有记录的集合。每个任务 `t ∈ T` 封装了一个算子实例的独立运行，其由以下内容组成：
- 一组输入和输出通道 `It , Ot ⊆ E`
- 算子状态 `St`
- 用户自定义函数 `ft` 。
在执行过程中，每个任务消耗输入记录，更新算子状态并根据其用户自定义函数生成新的记录。对于流入算子的每一条数据 `r ∈ M`，通过 `UDF`，产生一个新的状态值 `st’`，同时产生一个新的输出的集合 `D ⊆ M`。

### 3. 异步屏障快照

为了提供一致性结果，分布式处理系统需要对失败任务进行恢复。提供这种弹性的一种方法是定期捕获执行图的快照，然后可以用它来从故障中恢复。快照是执行图的全局状态，捕获所有必要信息以从该特定执行状态重新开始计算。

#### 3.1 问题定义

我们别定义了一个执行图 `G =（T，E）` 的全局快照 `G * =（T *，E *）`，其中 `T *` 和 `E *` 分别表示所有任务和边的状态集合。更详细地说，`T *` 由所有算子状态组成 `St * ∈ T *`， `∀t ∈ T`， `E *` 是所有通道状态 `e * ∈ E *` 的集合，其中 `e *` 由在 `e` 上传输的记录组成。

我们确保每个快照 `G *` 都保留某些属性，例如最终性 `Termination` 和可行性 `Feasibility`，以便在故障恢复后保证结果的正确性。最终性保证，如果所有进程都处于活跃状态，那么快照算法最终会在启动后的有限时间内完成。可行性表达了快照的意义，即在快照过程中关于计算的信息不会丢失。



































原文:
