---
layout: post
author: sjf0115
title: 列式存储 vs 行式存储
date: 2018-09-25 20:39:01
tags:
  - 存储

categories: 存储
permalink: the-difference-between-row-storage-and-columnar-storage
---


磁盘仍然是在大型数据集上执行查询的主要瓶颈。即使是具有12个并行运行的磁盘的机器也无法充分利用所有核；在内存缓存数据上执行查询可以获得数十GB/s的吞吐量。IO带宽很重要。因此，如果要提高基于磁盘的查询引擎（如RDBM和Impala）的性能，最好是提高从磁盘读取的性能。如果这样做，可能意味着减少延迟（短查询中查找要读取数据的时间可能占主导地位），但大多数情况下通常意味着提高从磁盘读取的有效吞吐量。

提高磁盘带宽的传统方法是等待，以及使磁盘运转更快。但是，磁盘一般都不是很快（大约100MB/s，每台服务器大约12个磁盘）。

提高磁盘性能的另一种方法是最大化读取`有用`字节与读取总字节数的比值。我们的想法是不要读取比查询所需要的数据多，因此有用的带宽会增加，但是IO子系统的性能并不会实际提高。对于列式存储，文件格式设计的一个原则是旨在为完成基于记录数据处理的查询引擎做到这一点。

### 1. 列 vs 行

传统数据库文件格式以行的形式存储数据，其中每一行由一组连续的列值组成。在磁盘上，看起来大致如下：

![]()

以行为主的布局通常具有描述行的 `Row Header`，例如，该行中的哪些列为 `NULL`。然后，每个列的值在 `Row Header` 之后连续存储，后面是具有它自己的 `Row Header` 的另一行，依此类推。

当从磁盘顺序读取数据时，对HDD和SSD都是最高效的方式（对于HDD而言，其优势尤其明显）。事实上，即使读取几个字节也会从磁盘中获取整个4096字节的块，因为实际上这两种方式读取成本是相同的。因此，对于以行为主的布局，一次读取整行是最有效的。

执行全表扫描的查询，即那些不利用任何索引并需要访问每一行的查询，在数据分析中很常见。对于以行为主的布局，全表扫描将从磁盘读取表的每个字节。对于某些查询，这是合适的。简而言之，`SELECT * FROM table` 需要返回表中每一行的每一列，因此以行为主的布局执行该查询的IO成本是一次寻道和一次大型连续读取（尽管很可能为了流水线目的而分解）。不可避免的读取，也不可避免的进行一次寻道；因此以行为主的布局有最佳的IO使用。更一般地，`SELECT FROM table WHERE` 对于以行为主的布局将是相对有效，如果
- 评估 `predicate_set` 需要读取很多列。
- `col_set` 是列集合中比较大的子集（即，投影性比较高），通过对表的谓词的评估返回的行集占整个行集的很大一部分（即选择性比较高）。
更简单地说，如果查询需要读取大多数行中的大多数列，那么将会非常高效。在这些情况下，以行为主的布局的查询执行引擎有比较好的IO效率。

但是，人们普遍认为这些 `SELECT *` 类型的查询并不代表典型的分析性工作负载；相反，要么不投影大量的列，要么仅针对一少部分行进行投影，其中只需要几列来决定返回哪些行。与具有非常多列的宽表相结合，满足查询所需的总字节数通常只占目标表磁盘大小的一少部分。在这些情况下，以行为主的布局在执行查询所需的IO量方面通常非常浪费。

对于分析性处理可以高效的一次读取整个列，而不是读取整行。根据我们对磁盘效率的理解，我们可以知道常用的方法是在磁盘上密集和连续地存储列值。这是列式文件格式背后的基本思想。下图显示了磁盘上的内容：

![]()

一行分为几个列块，甚至可能是磁盘上的单独文件。 现在读取整个列需要单个搜索和大的连续读取，但读取长度远小于从行主格式中提取单个列的读取长度。 在这个图中，我们组织了列，以便它们以相同的方式排序; 稍后我们将看到我们如何放宽限制并使用不同的顺序来提高查询的效率。


### 2. 压缩

虽然今天的内存容量允许在内存中保留大量数据，但我们仍然需要考虑对内存中的数据进行压缩。目标是以不降低性能的方式压缩数据，同时最小化从RAM到处理器的数据移动。通过使用字典将文本表示为整数，数据库对数据的压缩非常显著，从而减少数据移动，同时不会为解压缩增加CPU负载。实际上，它也可以增加性能，如下图所示。这种情况有一个简化的例子，如下图所示：

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-1.png?raw=true)

上图左侧为原始表，包含原始表示形式的文本属性（即材料和客户名称）。文本属性值存储在字典中（右上角），并为每个不同的属性值分配一个整数值。表中，文本由字典中定义的相应整数值替换。日期和时间属性也会转换为整数形式。对文本属性使用字典形式会减小表的大小，因为每个不同的属性值只能在字典中存储一次。因此，表中的每个值必须引用相应的一个整数值。

通过此方法实现的压缩因子高度依赖于压缩的数据。不同值比较少的属性压缩得比较好，但不同值比较多的属性效果不会很好。

还有其他更有效的压缩方法可以用于内存计算。但是，要使用这些方法，必须在压缩效率之间做一个权衡（这样可以在内存中提供更多数据，或者更少的数据移动（即更高性能）），解压缩所需的资源以及数据可访问性（也就是说，必须解压缩多少不相关的数据才能获得所需的数据）。字典压缩将良好的压缩效率与少解压缩资源和数据访问灵活性相结合。

### 3. 列式存储 vs 行式存储

关系型数据库以包含数据记录的表的方式组织数据。基于行和基于列的存储之间的区别在于表的存储方式。基于行的存储将表存储在一系列行中（Row-based storage stores a table in a sequence of rows）。基于列的存储将表存储在一系列列中（Column-based storage stores a table in a sequence of columns）。基于行和基于列的模型如下图所示：

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-2.png?raw=true)

两种存储模型都有其优点和缺点，如下表所示：

|行式存储|列式存储
---|---|---
优点|数据存储在一起；`INSERT`/`UPDATE`操作比较方便|查询时可以只读取涉及到的列；投影比较高效；任何列都能作为索引
缺点|`SELECT`时即使只涉及某几列，也会读取所有列的数据|`SELECT`之后，被选择的行需要根据列重新组装；`INSERT`/`UPDATE`操作比较麻烦

基于列的存储的缺点并不像看起来那么严重。在大多数情况下，我们不会处理行的所有列，尤其是在分析型查询中。此外，在分析型环境中插入或更新数据的频率一般较低。

### 高效查询执行

为了展示字典压缩与列式存储结合使用的优点，下图展示了一个查询如何执行的示例。

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-3.png?raw=true)

> 图中使用到压缩章节中的数据表

查询客户为 `Miller` 并使用 `Refrigerator` 材料的所有记录。首先，去字典表里找到字符串对应数字(只进行一次字符串比较)。我们可以看到客户列中的 `Miller` 由数字4表示。材料列中的 `Refrigerator` 由数字3表示。这个过程只需要执行一次。

在第二步中，读取作为查询条件的列（即 `Customer`和 `Material` 两列，如图中的绿色标识），表中的其他列不需要考虑。然后扫描这两列来查找与查询条件匹配的值，在 `Customer` 列中所有出现的4都标记为选中，在 `Material` 列中所有出现的3都标记为选中。

这些标记可以用位图表示，可以使用布尔运算（逻辑与）将两列的位图（`Customer`，`Material`）合并为一个结果集的位图（`ResultSet`），表示整个查询条件匹配的记录。在这个示例中，我们看到只匹配到一个记录（编号为6，表示每列的第六个位置）。由于我们已经知道在每列中的位置（每列的第六个位置），因此只需要读取包含此记录数据的部分列即可。

此示例展示了压缩不仅可以降低选择过程必须读取的数据量，还可以简化选择过程，同时展示了列式存储模型还可以进一步减少选择过程所需的数据量。尽管这个示例比较简单，但它展示了字典压缩和列式存储的优点。

原文：https://www.the-paper-trail.org/post/2013-01-30-columnar-storage/

[](https://lenovopress.com/sg248086.pdf)
