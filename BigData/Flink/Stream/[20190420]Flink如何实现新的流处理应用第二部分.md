
这是我们关于 Flink 如何实现新的流处理应用系列中的第二篇博文。第一部分介绍了事件时间和乱序处理。

这篇文章是关于版本化应用程序状态，后面是关于会话和高级窗口的帖子（第3部分，可在此处获得）。

### 1. 有状态数据流处理

流处理可以分为无状态处理和有状态处理。无状态流处理应用仅仅接收事件，并且基于最近接收的单个事件(the last received event alone)上的记录信息产生某种响应(例如，警报或转换后的事件)。 因此，他们没有"记忆"或聚合能力。但是在许多场景下还是有用的(例如，过滤，简单的转换)，许多有趣的流处理应用，例如时间窗口上的聚合，复杂的事件处理，其他的模式匹配多个事件，以及事务处理都是有状态的。

![](https://raw.githubusercontent.com/sjf0115/PubLearnNotes/master/photo/state.png)

较早的流处理系统，如Apache Storm(在其core API上)，并不对状态提供支持(Storm Trident，Apache Storm通过附带的一个库来提供了对状态的支持)。Storm程序可以在bolts上定义一个Java对象来保存状态，或者与保存状态的外部数据库和键/值存储系统进行交互，但是在失败的情况下，系统并不能保证状态的正确性，可能回退到"at least once"语义(数据可能有重复)，或"at most once"语义(数据可能丢失)。这种缺乏准确性的保证，再加上无法处理大量数据流(高吞吐量)，使得像Lambda这样的混合解决方案成为必需。Flink代表了新一代的流处理系统，并保证了状态的正确性，这使得有状态的应用变得更加容易实现。在Flink程序中，你可以有多种方式定义状态：

(1) 使用Flink的窗口转换操作，你可以定义基于事件时间或处理时间的时间窗口，基于计数的窗口以及广义的自定义窗口。请参阅[这里](http://flink.apache.org/news/2015/12/04/Introducing-windows.html)了解Flink窗口的简短介绍。

(2) 使用检查点接口，你可以使用Flink注册任何类型的Java/Scala对象(例如，HashMap)，以确保在失败后能正确恢复。

(3) 使用Flink的key/value状态接口，你可以使用在群集上通过键分区的状态。

这个状态在哪里存储？首先，所有上述形式的状态都由Flink使用可配置的`state backend`在内部存储。目前，Flink将状态存储在内存中，并将该状态备份到文件系统(例如HDFS)中。我们正在积极努力提供额外的`state backends`和备份选项。例如，我们最近贡献了一个基于`RocksDB`的`state backend`，而且我们正在开发一个使用Flink管理内存的`state backend`，如果需要的话，可以从内存溢出到磁盘上。根据我们的经验，流式应用程序，特别是有状态的流式应用程序比批处理作业更难操作(a more operational nature)。批处理作业可以在一夜之间运行完，如果结果不符合要求或作业失败，可以重新运行。相比之下，流式作业每周7天，每天24小时不间断运行，应用程序通常面向用户的，因此不能随便地停止和重新运行。Flink线上用户有必要担心在作业升级(应用程序代码和Flink本身)，出现故障以及应用程序和群集维护过程中作业的表现情况。

### 2. 保存点：版本化状态

在Flink中，我们引入了保存点功能，a feature that brings Flink a long way towards resolving the above and more issues。保存点可以在正在运行的Flink作业上生成，实质上是在一个明确定义的一致时间内从外部访问作业的快照(essentially takes an externally accessible snapshot of the job at a well-defined consistent time)。它包含当前正在从流数据源读取数据的偏移量，以及正好在这个偏移量处的程序状态(the program state as it is at exactly this offset)。在内部，保存点只是Flink的定期检查点，以保证在发生故障时的正确性。主要区别是 (1) 保存点可以手动触发，(2) 保存点永不过期，除非用户手动进行处理。通过命令行使用给定的JobID获取正在运行的作业的保存点，只需运行:
```
flink savepoint JobID
```
这将返回存储保存点的路径(在默认的配置文件系统中，例如本地，HDFS，S3等)。要从该保存点恢复作业，只需运行如下即可:
```
flink run -s pathToSavePoint jobJar
```
使用保存点，不必从头开始重新读取事件流以重新填充Flink作业的状态，因为你可以随时获取一致性快照并从该检查点恢复。另外，当日志保留期限有限时，定期保存状态是有用的，因为日志不能从头开始读取。另一种考虑保存点的方法是在定义好的时间点保存应用程序状态的版本，类似于使用git等版本控制来保存应用程序的版本。最简单的例子是在更改应用程序代码的同时以一定时间间隔获取快照：

![](https://raw.githubusercontent.com/sjf0115/PubLearnNotes/master/photo/linear-300x179.png)

更重要的是，你可以从多个保存点分支出来，创建一个应用程序版本树：

![](https://raw.githubusercontent.com/sjf0115/PubLearnNotes/master/photo/tree-300x185.png)

这里，在时间t1和t2在正在运行的作业v0上生成两个保存点，创建版本v0t1和v0t2。他们都可以用来恢复作业。例如，利用t1时间点的保存点，使用更新的应用程序代码恢复作业，创建程序的v1版本。在时间t3和t4，分别从版本v0和v1获取更多的保存点。保存点可用于解决流式作业的各种线上问题：

(1) 应用程序代码升级：假设你在已经运行的应用程序中发现了一个bug，并且希望未来的事件能够通过修正错误后的代码来处理。通过获取作业的保存点，使用新的代码从该保存点重新启动，下游应用程序看不到任何差异(downstream applications will not see the difference)。

(2) Flink版本升级：升级Flink本身也变得很容易，因为你可以获取正在运行的管道的保存点并使用升级后Flink版本从保存点重新读取它们。

(3) 维护和迁移：使用保存点，可以轻松"暂停和恢复"应用程序。这对于群集维护以及将作业迁移到新群集尤其有用。另外，这对开发，测试和调试应用程序非常有用，因为你不需要读取已经完成的事件流。

(4) 假设模拟(复原):很多时候，运行一个可选的应用程序逻辑来模拟过去可控制点的"假设"场景非常有用。

(5) A/B测试：通过从完全相同的保存点并行运行两个不同版本的应用程序代码，可以对A/B测试场景进行建模。

### 3. 结论

通过这篇文章，我们可以看到:

(1) 许多有趣的流式使用案例，如在时间窗口上聚合，复杂的事件处理或模式匹配，在系统内都需要有状态程序的支持。Flink对状态的支持使这些类型的应用程序成为可能，并允许Flink对状态的正确性(确切地说是一种语义)做出保证。

(2) 有状态的流处理应用程序会面临许多操作上的问题，例如升级时表现(应用程序代码和Flink本身)，出现故障以及应用程序和群集维护。Flink对保存点的支持通过允许你对应用程序代码和状态进行版本化来帮助解决这些操作问题。

目前的限制是你程序的并发度必须与生成保存点的程序的并发度相匹配。为了开始使用保存点，请查看有关[保存点如何工作](https://ci.apache.org/projects/flink/flink-docs-release-1.4/ops/state/savepoints.html)的文档以及如何[从Flink的命令行使用它们](https://ci.apache.org/projects/flink/flink-docs-release-1.4/ops/cli.html)。




















原文:[]()
